# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2018, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6 TW\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-26 18:54+0800\n"
"PO-Revision-Date: 2018-07-22 20:37+0800\n"
"Last-Translator: Liang-Bo Wang <me@liang2.tw>\n"
"Language-Team: Chinese Traditional (http://www.transifex.com/python-tw-doc/"
"python-36-tw/language/zh-Hant/)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 2.0.9\n"

#: ../../tutorial/floatingpoint.rst:9
msgid "Floating Point Arithmetic:  Issues and Limitations"
msgstr "浮點數算術：問題與限制"

#: ../../tutorial/floatingpoint.rst:14
msgid ""
"Floating-point numbers are represented in computer hardware as base 2 "
"(binary) fractions.  For example, the decimal fraction ::"
msgstr ""
"浮點數，在電腦以基數為 2（binary）分數來表示。舉例說明，在十進位分數：\n"
"::"

#: ../../tutorial/floatingpoint.rst:19
msgid ""
"has value 1/10 + 2/100 + 5/1000, and in the same way the binary fraction ::"
msgstr ""
"如 1/10 + 2/100 + 5/1000 以二進位分數方式表示為：\n"
"::"

#: ../../tutorial/floatingpoint.rst:23
msgid ""
"has value 0/2 + 0/4 + 1/8.  These two fractions have identical values, the "
"only real difference being that the first is written in base 10 fractional "
"notation, and the second in base 2."
msgstr ""
"0/2 + 0/4 + 1/8。  這兩種分數具有相同數值，唯一差別為第一種標記法是十進位分"
"數，而第二種為二進位分數。"

#: ../../tutorial/floatingpoint.rst:27
msgid ""
"Unfortunately, most decimal fractions cannot be represented exactly as "
"binary fractions.  A consequence is that, in general, the decimal floating-"
"point numbers you enter are only approximated by the binary floating-point "
"numbers actually stored in the machine."
msgstr ""
"不幸的是，大多數十進位轉換成二進位表示的分數，其數值並不完全相同。  最後常見"
"的情況是，當您輸入十進位的浮點數值，計算機將轉換為近似的二進位浮點數值儲存。"

#: ../../tutorial/floatingpoint.rst:32
msgid ""
"The problem is easier to understand at first in base 10.  Consider the "
"fraction 1/3.  You can approximate that as a base 10 fraction::"
msgstr ""
"以十進位較容易理解問題。  但以十進位分數來表達數值 1/3 時：\n"
"::"

#: ../../tutorial/floatingpoint.rst:37 ../../tutorial/floatingpoint.rst:41
msgid "or, better, ::"
msgstr "只能得到近似值："

#: ../../tutorial/floatingpoint.rst:45
msgid ""
"and so on.  No matter how many digits you're willing to write down, the "
"result will never be exactly 1/3, but will be an increasingly better "
"approximation of 1/3."
msgstr "不論你小數寫到多少位，數值結果都只能逼近但無法等同表示 1/3。"

#: ../../tutorial/floatingpoint.rst:49
msgid ""
"In the same way, no matter how many base 2 digits you're willing to use, the "
"decimal value 0.1 cannot be represented exactly as a base 2 fraction.  In "
"base 2, 1/10 is the infinitely repeating fraction ::"
msgstr ""
"同樣，二進位數值不論到第幾位也無法精確等同數值 0.1。  在二進位中，1/10 是無窮"
"盡的分數。"

#: ../../tutorial/floatingpoint.rst:55
msgid ""
"Stop at any finite number of bits, and you get an approximation.  On most "
"machines today, floats are approximated using a binary fraction with the "
"numerator using the first 53 bits starting with the most significant bit and "
"with the denominator as a power of two.  In the case of 1/10, the binary "
"fraction is ``3602879701896397 / 2 ** 55`` which is close to but not exactly "
"equal to the true value of 1/10."
msgstr ""
"有限的位數中，只能得到近似數值。  現今機器上，浮點數是以二進位分數近似表示"
"的，使用從 53 位開始的最高有效數（significant bit），分母為 2 的指數倍。  以"
"數值 1/10 說明，二進制分數表示為 \" 3602879701896397 / 2 ** 55 \"，其接近但不"
"精確等同數值 1/10。"

#: ../../tutorial/floatingpoint.rst:62
msgid ""
"Many users are not aware of the approximation because of the way values are "
"displayed.  Python only prints a decimal approximation to the true decimal "
"value of the binary approximation stored by the machine.  On most machines, "
"if Python were to print the true decimal value of the binary approximation "
"stored for 0.1, it would have to display ::"
msgstr ""
"由於值的顯示方式，許多用戶沒意識到顯示的數值為近似值。 現況是，真實十進制值以"
"二進制近似值存儲到機器，由 Python 再二次轉換印出十進制近似值來顯示。在大多數"
"機器上，對於真實的十進制值 0.1，如果 Python 要印出小數值為存儲的二進制近似"
"值，則必須顯示為：\n"
"::"

#: ../../tutorial/floatingpoint.rst:71
msgid ""
"That is more digits than most people find useful, so Python keeps the number "
"of digits manageable by displaying a rounded value instead ::"
msgstr ""
"這比大多數人認為有用的位數多，因此 Python 透過選擇顯示方式來管理位數的捨入。"

#: ../../tutorial/floatingpoint.rst:77
msgid ""
"Just remember, even though the printed result looks like the exact value of "
"1/10, the actual stored value is the nearest representable binary fraction."
msgstr ""
"請記住，即使印出的結果看起來像 1/10 的精確值，實際存儲的值也是逼近的二進位分"
"數。"

#: ../../tutorial/floatingpoint.rst:80
msgid ""
"Interestingly, there are many different decimal numbers that share the same "
"nearest approximate binary fraction.  For example, the numbers ``0.1`` and "
"``0.10000000000000001`` and "
"``0.1000000000000000055511151231257827021181583404541015625`` are all "
"approximated by ``3602879701896397 / 2 ** 55``.  Since all of these decimal "
"values share the same approximation, any one of them could be displayed "
"while still preserving the invariant ``eval(repr(x)) == x``."
msgstr ""
"有趣的是, 有許多不同的十進位數共用相同的近似二進位分數。 例如，數值 \"0.1\" "
"和 \"0.10000000000000001\" 和 "
"\"0.1000000000000000055511151231257827021181583404541015625\" 都是 "
"\"3602879701896397/2 ** 55\" 的近似值。 由於所有這些十進位值都具有相同的逼近"
"值，為區分差異因此以 \"eval (repr (x)) == x\" 的方式保留表示。"

#: ../../tutorial/floatingpoint.rst:88
msgid ""
"Historically, the Python prompt and built-in :func:`repr` function would "
"choose the one with 17 significant digits, ``0.10000000000000001``.   "
"Starting with Python 3.1, Python (on most systems) is now able to choose the "
"shortest of these and simply display ``0.1``."
msgstr ""
"歷史上，Python 內建函數\\ :func: ' repr '\\ 提示為一個具有 17 位有效數值，如 "
"\"0.10000000000000001\"。  從 python 3.1 開始，在眾系統上 python 已可以選擇簡"
"化顯示成 \"0.1\"。"

#: ../../tutorial/floatingpoint.rst:93
msgid ""
"Note that this is in the very nature of binary floating-point: this is not a "
"bug in Python, and it is not a bug in your code either.  You'll see the same "
"kind of thing in all languages that support your hardware's floating-point "
"arithmetic (although some languages may not *display* the difference by "
"default, or in all output modes)."
msgstr ""
"請注意, 這是二進位浮點數定義的本質：這不是 Python ，也不是你程式碼中的 bug。 "
"同樣地，在所有支援硬體浮點運算的程式語言中情況亦相同（儘管某些語言可能預設在"
"各種輸出模式中沒差異，如輸出列印＊顯示＊）。"

#: ../../tutorial/floatingpoint.rst:99
msgid ""
"For more pleasant output, you may wish to use string formatting to produce a "
"limited number of significant digits::"
msgstr ""
"考量有效數字輸出的閱讀性，你會想到採用字串格式來限制輸出的位數的方法：\n"
":: "

#: ../../tutorial/floatingpoint.rst:111
msgid ""
"It's important to realize that this is, in a real sense, an illusion: you're "
"simply rounding the *display* of the true machine value."
msgstr "重要且明白易曉地：為了簡化顯示數值，機器紀錄的真值被四捨五入了。"

#: ../../tutorial/floatingpoint.rst:114
msgid ""
"One illusion may beget another.  For example, since 0.1 is not exactly 1/10, "
"summing three values of 0.1 may not yield exactly 0.3, either::"
msgstr ""
"這使得運算可能一錯再錯，例如： 0.1 並不是真的 1/10 ，導致三個 0.1 加總也不是"
"等於 0.3 。"

#: ../../tutorial/floatingpoint.rst:120
msgid ""
"Also, since the 0.1 cannot get any closer to the exact value of 1/10 and 0.3 "
"cannot get any closer to the exact value of 3/10, then pre-rounding with :"
"func:`round` function cannot help::"
msgstr ""
"再者，既然 0.1 無法逼近 1/10，而 0.3 也不真正等於 3/10，則預先用捨入\\ :func:"
"`round`\\ 函數也沒有幫助：\n"
"::"

#: ../../tutorial/floatingpoint.rst:127
msgid ""
"Though the numbers cannot be made closer to their intended exact values, "
"the :func:`round` function can be useful for post-rounding so that results "
"with inexact values become comparable to one another::"
msgstr ""
"雖然數字不能接近它們預期的精確值，但是函數\\ :func:`round` \\用於計算後舍入卻"
"有幫助，這樣後捨入值與不精確值的結果可以兩相比較：\n"
"::"

#: ../../tutorial/floatingpoint.rst:134
msgid ""
"Binary floating-point arithmetic holds many surprises like this.  The "
"problem with \"0.1\" is explained in precise detail below, in the "
"\"Representation Error\" section.  See `The Perils of Floating Point <http://"
"www.lahey.com/float.htm>`_ for a more complete account of other common "
"surprises."
msgstr ""
"二進位浮點數計算有許多這樣的意料之外。如 \"0.1\" 的問題說明請參照下面 \"表示"
"錯誤 Representation Error\" 的部分。 看到\\ `浮點數的危險 The Perils of "
"Floating Point<http: www.lahey.com/float.htm>`_ 更完整地描述其他常見的意外。"

#: ../../tutorial/floatingpoint.rst:139
msgid ""
"As that says near the end, \"there are no easy answers.\"  Still, don't be "
"unduly wary of floating-point!  The errors in Python float operations are "
"inherited from the floating-point hardware, and on most machines are on the "
"order of no more than 1 part in 2\\*\\*53 per operation.  That's more than "
"adequate for most tasks, but you do need to keep in mind that it's not "
"decimal arithmetic and that every float operation can suffer a new rounding "
"error."
msgstr ""
"最後提醒，「答案沒那麼簡單的 」。 不過，別對浮點數吹毛求疵！承襲自電腦硬體對"
"浮點數的儲存問題， Python 浮點數運算中也會關聯的錯誤，但大多數機器在每次計算"
"差異不超過二的五十三次方分之一 （1/2** 53）內。 這足以勝任大多數任務，但請記"
"住，它不是十進位運算，所以每次浮點運算都可能產生新的舍入錯誤。"

#: ../../tutorial/floatingpoint.rst:146
msgid ""
"While pathological cases do exist, for most casual use of floating-point "
"arithmetic you'll see the result you expect in the end if you simply round "
"the display of your final results to the number of decimal digits you "
"expect. :func:`str` usually suffices, and for finer control see the :meth:"
"`str.format` method's format specifiers in :ref:`formatstrings`."
msgstr ""
"雖然浮點運算上存在差異問題，常態上是以十進位方式的四捨五入顯示最終結果，那仍"
"會得到您預期的結果。\\ :func:`str`\\ 通常就足夠了，為了更好的控制，請參閱 :"
"meth:`str.format` ，規範的格式方法 :ref:`formatstrings`。"

#: ../../tutorial/floatingpoint.rst:152
msgid ""
"For use cases which require exact decimal representation, try using the :mod:"
"`decimal` module which implements decimal arithmetic suitable for accounting "
"applications and high-precision applications."
msgstr ""
"對於需要精確十進位表示形式的應用上，試著使用 :mod:`decimal` 十進位模組，它適"
"用於各類會計應用與高精度應用的十進位運算。"

#: ../../tutorial/floatingpoint.rst:156
msgid ""
"Another form of exact arithmetic is supported by the :mod:`fractions` module "
"which implements arithmetic based on rational numbers (so the numbers like "
"1/3 can be represented exactly)."
msgstr ""
"另一種支援精確運算的格式為 :mod:`fractions` 分數模塊，該模塊基於有理數來進行"
"運算（因此可以精確表示像 1/3 這樣的數字）。"

#: ../../tutorial/floatingpoint.rst:160
msgid ""
"If you are a heavy user of floating point operations you should take a look "
"at the Numerical Python package and many other packages for mathematical and "
"statistical operations supplied by the SciPy project. See <https://scipy."
"org>."
msgstr ""
"如果您重度使用浮點運算在數學和統計學操作上，您應該查看 Numerical Python 以及"
"由 SciPy 專案提供的許多軟件包。請參照 <https://scipy.org>。"

#: ../../tutorial/floatingpoint.rst:164
msgid ""
"Python provides tools that may help on those rare occasions when you really "
"*do* want to know the exact value of a float.  The :meth:`float."
"as_integer_ratio` method expresses the value of a float as a fraction::"
msgstr ""
"當你罕見情況下想知道確切的浮點數值，Python 提供的工具可協助達成。 :meth:"
"`float.as_integer_ratio` 方法將 float （浮點數）的值表示為分數：\n"
"::"

#: ../../tutorial/floatingpoint.rst:173
msgid ""
"Since the ratio is exact, it can be used to losslessly recreate the original "
"value::"
msgstr ""
"由於比率是精確的，它可無損地重創原始值：\n"
"::"

#: ../../tutorial/floatingpoint.rst:179
msgid ""
"The :meth:`float.hex` method expresses a float in hexadecimal (base 16), "
"again giving the exact value stored by your computer::"
msgstr ""
":meth:`float.hex` 方法用十六進制表示浮點數（基數為16），可等同存儲於計算機的"
"確切值：\n"
"::"

#: ../../tutorial/floatingpoint.rst:185
msgid ""
"This precise hexadecimal representation can be used to reconstruct the float "
"value exactly::"
msgstr ""
"這種精確的十六進位標記法可用於重建確切的浮點值：\n"
"::"

#: ../../tutorial/floatingpoint.rst:191
msgid ""
"Since the representation is exact, it is useful for reliably porting values "
"across different versions of Python (platform independence) and exchanging "
"data with other languages that support the same format (such as Java and "
"C99)."
msgstr ""
"由於標記法是精確的，因此在不同版本的 Python（獨立平台）之間可信賴地進行數值的"
"轉移，並與支援相同格式的其他語言（如 JAVA 和 C99）交換資料。"

#: ../../tutorial/floatingpoint.rst:195
msgid ""
"Another helpful tool is the :func:`math.fsum` function which helps mitigate "
"loss-of-precision during summation.  It tracks \"lost digits\" as values are "
"added onto a running total.  That can make a difference in overall accuracy "
"so that the errors do not accumulate to the point where they affect the "
"final total:"
msgstr ""
"另一個有用的工具是 :func:`math.fsum` 功能，在加總計算中有效減少精度損失。 當"
"數值作總體運算時，它會去追蹤丟失的位數 \"lost digits\"。 這樣錯誤就不會累積到"
"影響最終總計的節點上，使總精度上有所差異："

#: ../../tutorial/floatingpoint.rst:209
msgid "Representation Error"
msgstr "標記誤差"

#: ../../tutorial/floatingpoint.rst:211
msgid ""
"This section explains the \"0.1\" example in detail, and shows how you can "
"perform an exact analysis of cases like this yourself.  Basic familiarity "
"with binary floating-point representation is assumed."
msgstr ""
"本節以 \"0.1\" 示例且詳細解釋了，並說明你要如何對此類案例進行精確分析。 假定"
"你對二進位浮點表示有基本熟悉的程度。"

#: ../../tutorial/floatingpoint.rst:215
msgid ""
":dfn:`Representation error` refers to the fact that some (most, actually) "
"decimal fractions cannot be represented exactly as binary (base 2) "
"fractions. This is the chief reason why Python (or Perl, C, C++, Java, "
"Fortran, and many others) often won't display the exact decimal number you "
"expect."
msgstr ""
":d fn:`Representation error` 「標記誤差」真正指的是，實際上大多數十進位分數並"
"不能精確以二進位（基數為 2）分數標示。這是 Python （或 Perl、c、c++、JAVA、"
"Fortran 和其他許多）通常不會顯示您期望的確切十進位數的主要原因。"

#: ../../tutorial/floatingpoint.rst:220
msgid ""
"Why is that?  1/10 is not exactly representable as a binary fraction. Almost "
"all machines today (November 2000) use IEEE-754 floating point arithmetic, "
"and almost all platforms map Python floats to IEEE-754 \"double precision"
"\".  754 doubles contain 53 bits of precision, so on input the computer "
"strives to convert 0.1 to the closest fraction it can of the form *J*/2**\\ "
"*N* where *J* is an integer containing exactly 53 bits.  Rewriting ::"
msgstr ""
"為什麼呢？ 因 1/10 無法精確標示為二進位分數。至今（2000年11月）幾乎所有的電腦"
"皆使用 IEEE-754 規範作浮點運算，並且幾乎所有的平台制定 Python 浮點依據 "
"IEEE-754 規範為「雙重精確度」 \"double precision\"。  754 double 包含 53 "
"bits 位元的精度，所以輸入的電腦努力轉換 0.1 到最接近的分數，它以 / *J*/2 **"
"\\ *N* 形式顯示，此處 *J* 是一個精確地包含 53 bits 位元整數。 重寫：\n"
"::"

#: ../../tutorial/floatingpoint.rst:229
msgid "as ::"
msgstr ""
"成：\n"
"::"

#: ../../tutorial/floatingpoint.rst:233
msgid ""
"and recalling that *J* has exactly 53 bits (is ``>= 2**52`` but ``< "
"2**53``), the best value for *N* is 56::"
msgstr ""
"再提到 *J* 的確有精確到 53 bits 位元（是 ``>> = 2**52`` 但 ``2**53``）， 最佳"
"的 *N* 數值為是 56：\n"
"::"

#: ../../tutorial/floatingpoint.rst:239
msgid ""
"That is, 56 is the only value for *N* that leaves *J* with exactly 53 bits.  "
"The best possible value for *J* is then that quotient rounded::"
msgstr ""
"即， *N* 是為 56 的數值，而 *J* 指的卻是 53 bits 位元。 *J* 最可能的數值為取"
"商數作四捨五入：\n"
"::"

#: ../../tutorial/floatingpoint.rst:246
msgid ""
"Since the remainder is more than half of 10, the best approximation is "
"obtained by rounding up::"
msgstr ""
"由於餘數超過了 10，最佳的近似值是通過四捨五入得到的：\n"
"::"

#: ../../tutorial/floatingpoint.rst:252
msgid ""
"Therefore the best possible approximation to 1/10 in 754 double precision "
"is::"
msgstr ""
"所以在 754 double 精確度下， 1/10 最佳近似值是：\n"
"::"

#: ../../tutorial/floatingpoint.rst:256
msgid ""
"Dividing both the numerator and denominator by two reduces the fraction to::"
msgstr ""
"將分子和分母同除以二，將分數降到：\n"
"::"

#: ../../tutorial/floatingpoint.rst:260
msgid ""
"Note that since we rounded up, this is actually a little bit larger than "
"1/10; if we had not rounded up, the quotient would have been a little bit "
"smaller than 1/10.  But in no case can it be *exactly* 1/10!"
msgstr ""
"請注意，由於我們四捨五入，這實際上比 1/10 大一點；如果我們沒有四捨五入，商數"
"將是有點小於 1/10。 但在任何情況下都不可能是「精確的」 1/10！"

#: ../../tutorial/floatingpoint.rst:264
msgid ""
"So the computer never \"sees\" 1/10:  what it sees is the exact fraction "
"given above, the best 754 double approximation it can get::"
msgstr ""
"所以電腦從來沒有 「看到」 1/10：  它看到是的如上述提到的精確分數，最佳的 754 "
"double 近似可以得到：\n"
"::"

#: ../../tutorial/floatingpoint.rst:270
msgid ""
"If we multiply that fraction by 10\\*\\*55, we can see the value out to 55 "
"decimal digits::"
msgstr ""
"如果將該分數乘以 10\\*\\*55，則可以將值顯示為 55 個十進位位數：\n"
"::"

#: ../../tutorial/floatingpoint.rst:276
msgid ""
"meaning that the exact number stored in the computer is equal to the decimal "
"value 0.1000000000000000055511151231257827021181583404541015625. Instead of "
"displaying the full decimal value, many languages (including older versions "
"of Python), round the result to 17 significant digits::"
msgstr ""
"這意味著存儲在電腦中的確切數值等於十進位值 "
"0.1000000000000000055511151231257827021181583404541015625。而不是顯示完整的十"
"進位數值，許多語言（包括 Python 的舊版本）， 將結果舍入為 17 個有效數字：\n"
"::"

#: ../../tutorial/floatingpoint.rst:284
msgid ""
"The :mod:`fractions` and :mod:`decimal` modules make these calculations "
"easy::"
msgstr ""
"這些使用 :mod:`fractions` 分數與 :mod:`decimal` 十進位模組使計算變得容易：\n"
"::"
